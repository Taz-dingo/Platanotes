---
created: 星期五, 八月 30日 2024, 10:01:16 晚上, 1725026476000
modified: 星期五, 八月 30日 2024, 10:01:16 晚上, 1725026476000
---

都可以用`dp[i][j]`来表示`s[i]~s[j]`的子串/子序列
子串是连续的，可能要用true/false来表示每个状态
子序列可以不连续，所以每次都是尝试更新最大值


[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)
```typescript
/**
dp[i][j] s[i]~s[j]是否是回文子串

if(s[i] === s[j] && dp[i+1][j-1]){
    dp[i][j] = true;
}

初始化为false，j-i <= 1的初始化为true

行、列；倒序、正序
 */
function countSubstrings(s: string): number {
    const n = s.length;
    const dp = new Array(n).fill(false).map(_=>new Array(n).fill(false)); // 最大为dp[n-1][n-1];
    let cnt = 0;

    for(let i = n-1;i >= 0;i--){
        for(let j = i;j < n;j++){
            if(s[i] === s[j] && (j - i <= 1 || dp[i+1][j-1])){
                dp[i][j] = true;
            }
            if(dp[i][j]) cnt++;
        }
    }

    return cnt;
};
```

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
```typescript
/**
dp[i][j] s[i]~s[j]是否是回文串

初始化为false
dp[i][i] 为true

s[i] === s[j]
1. i === j 
2. i+1 === j
3. j - i > 1 dp[i+1][j-1]
 */
function longestPalindrome(s: string): string {
    const dp = new Array(s.length).fill(false).map(()=> new Array(s.length).fill(false))
    let start = 0,maxLen = 0;

    for(let i = s.length-1;i >= 0;i--){
        for(let j = i;j < s.length;j++){
            if(s[i] === s[j] && (j-i <= 1 || dp[i+1][j-1])){
                dp[i][j] = true;
            }
            
            if(dp[i][j] && j - i + 1 > maxLen){
                maxLen = j - i + 1;
                start = i;
            }
        }
    }

    return s.slice(start,start+maxLen);
};
```


### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```typescript
/**
dp[i][j] s[i]~s[j]最长回文子序列长度

if(s[i] === s[j]){
    dp[i][j] = dp[i+1][j-1] + 2;
}else{
    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
}

初始化为1
 */

function longestPalindromeSubseq(s: string): number {
    if(s.length === 1) return 1;
    const dp = new Array(s.length).fill(null).map(_=>new Array(s.length).fill(0));
    let maxLen = 0;

    for(let i = 0;i < s.length;i++){
        dp[i][i] = 1;
    }

    for(let i = s.length - 1;i >= 0;i--){
        for(let j = i+1;j < s.length;j++){
            if(s[i] === s[j]){
                dp[i][j] = dp[i+1][j-1] + 2;
            }else{
                dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
            }

            maxLen = Math.max(maxLen,dp[i][j]);
        }
    }

    return maxLen;
};
```