---
created: 星期四, 十月 3日 2024, 12:17:54 凌晨, 1727885874754
modified: 星期四, 十月 3日 2024, 12:17:54 凌晨, 1727885874754
---


[46. 携带研究材料（第六期模拟笔试）](https://kamacoder.com/problempage.php?pid=1046)
```js
const r1 = require('readline').createInterface({
    input:process.stdin
})
var iter = r1[Symbol.asyncIterator]();
const readline = async()=>(await iter.next()).value;
/*
dp[i][j] 0~i种物品、容量j的最大价值

if(j < weights[i]) dp[i][j] = dp[i-1][j];
else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weights[i]]+values[i])

初始化为0
先物品再背包

*/
(async function(){
    const [m,n] = (await readline()).split(" ").map(Number);
    const weights = (await readline()).split(" ").map(Number);
    const values = (await readline()).split(" ").map(Number);
    const dp = new Array(m).fill(0).map(()=>new Array(n+1).fill(0));
    
    for(let j = weights[0];j <= n;j++){
        dp[0][j] = values[0];
    }
    
    for(let i = 1;i < m;i++){
        for(let j = 0;j <= n;j++){
            if(j < weights[i]) dp[i][j] = dp[i-1][j];
            else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weights[i]]+values[i])
        }
    }
    
    console.log(dp[m-1][n]);
})()
```

[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
```typescript
/**
0-1背包，weight和value都为数组元素，容量为sum/2
dp[j] 容量j背包的最大价值
dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]);
倒序，不可重复取
 */
function canPartition(nums: number[]): boolean {
    const sum = nums.reduce((pre,cur)=>pre+=cur,0);
    if(sum % 2 === 1) return false;
    const dp = new Array(sum/2 + 1).fill(0);

    for(let i = 0;i < nums.length;i++){
        for(let j = sum/2;j >= nums[i];j--){
            dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
        }
    }

    return dp[sum/2] === sum/2;
};
```


[1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) 尽可能凑够sum/2
```typescript
/**
和尽量对半开
dp[j] 空间j时的最大价值，weight和value都是数组元素

dp[j] = Math.max(dp[j],dp[j-1]+stones[i]);

压缩空间，倒序
 */
function lastStoneWeightII(stones: number[]): number {
    const sum = stones.reduce((pre,cur)=>pre += cur,0);
    const half = Math.floor(sum/2);
    const dp = new Array(half + 1).fill(0);

    for(let i = 0;i < stones.length;i++){
        for(let j = half;j >= stones[i];j--){
            dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
        }
    }

    return sum - 2*dp[half];
};
```