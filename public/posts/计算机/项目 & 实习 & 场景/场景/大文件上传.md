TAG: 场景
DECK: 前端
## 大文件上传
实现大文件上传的前端部分通常涉及以下几个步骤和难点：

### 实现步骤
1. **文件选择**：
   - 使用 `<input type="file">` 让用户选择文件。
   - 可以通过 `accept` 属性限制文件类型。
2. **分块计算hash上传**：
   - 将大文件分成多个小块，避免一次性上传导致的网络超时或失败。
   - 可以使用 `File.slice()` 方法来获取文件的不同部分。
3. **创建上传请求**：
   - 使用 `XMLHttpRequest` 或 `fetch` API 发送每个文件块。
   - 需要考虑支持 `FormData` 对象，以便轻松处理文件数据。
4. **进度监控**：
   - 利用 `XMLHttpRequest.upload.onprogress` 或 `fetch` 的进度回调来显示上传进度。
5. **错误处理**：
   - 处理上传过程中可能出现的错误，如网络中断、超时等，并实现重试机制。

### 难点
1. **文件分块策略**：
   - 如何合理划分文件块的大小，过小可能导致过多的请求，过大可能导致一次性上传失败。
2. **完整性校验：** 
   - 计算文件的完整哈希值、分块哈希值。
3. **进度反馈**：
   - 如何在用户界面上提供清晰的上传进度反馈，使用户能够了解当前状态。
4. **重试机制**：
   - 设计一个有效的重试机制，以确保上传在遇到错误时能够恢复。
5. **跨域问题**：
   - 上传请求可能会受到CORS（跨域资源共享）政策的限制，需要后端支持。
6. **安全性**：
   - 需要确保上传的文件安全，避免恶意文件的上传。

以下是一个简单的分块上传的示例代码：
```javascript
const uploadFile = async (file) => {
  const chunkSize = 1024 * 1024; // 1MB per chunk
  const totalChunks = Math.ceil(file.size / chunkSize);
  
  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);

    const formData = new FormData();
    formData.append('file', chunk, file.name);

    try {
      const response = await fetch('/upload', {
        method: 'POST',
        body: formData,
      });
      // 处理响应
    } catch (error) {
      console.error('Upload failed:', error);
      // 实现重试逻辑
    }
  }
};
```

通过这些步骤和注意事项，你可以实现一个有效的大文件上传功能。

END
<!--ID: 1727577275762-->
