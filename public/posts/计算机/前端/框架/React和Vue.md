TAG: 框架
DECK: 前端
## React和Vue

### 核心思想
和大部分前端框架一样，都是UI = f(state)，即数据变化映射到UI变化。

### 实现方式
- **Vue 是响应式的**：Vue 的核心是通过 **响应式系统**（可变数据）自动追踪数据的依赖，当数据变化时，Vue 自动检测并更新 UI。开发者不需要手动管理状态的更新，数据变化会自动触发相应的视图渲染。
- **React 是状态驱动的**：React 的设计理念是基于 **状态驱动**（数据不可变）的。开发者需要手动更新组件的状态，状态变化时 React 会触发 UI 的重新渲染。React 不会自动追踪依赖，所有的状态更新必须通过显式调用 `setState`（类组件）或 `useState`（函数组件）来完成。

| 特性         | Vue                          | React                                          |
| ---------- | ---------------------------- | ---------------------------------------------- |
| **数据更新机制** | 响应式系统，自动追踪依赖，监听数据变化          | 显式状态更新，通过 `setState` 或 `useState` 触发           |
| **依赖追踪**   | 自动追踪数据依赖                     | 不追踪依赖，所有状态变化都会触发重新渲染                           |
| **更新方式**   | 精准更新，受影响的组件自动更新              | 虚拟 DOM diff 算法，手动控制状态更新                        |
| **状态管理**   | 双向数据绑定，使用 `ref` 和 `reactive` | 单向数据流，状态通过 `props` 和 `state` 传递                |
| **性能优化**   | 依赖追踪，自动避免不必要的更新              | 虚拟 DOM 和 diff 算法，手动控制渲染优化，如 `memo` 和 `useMemo` |
React 和 Vue 在数据更新和 UI 渲染机制上有着不同的实现方式。Vue 通过响应式系统和依赖追踪实现数据变化的自动监听，而 React 则依赖组件状态（`state`）和虚拟 DOM 来进行数据更新。以下是两者在数据更新方面的详细对比。


### **Vue 的响应式系统**

Vue 的核心是其 **响应式系统**，它通过劫持对象属性的 **getter 和 setter** 来实现数据追踪和自动更新。这种机制使得 Vue 可以高效地追踪数据的依赖关系，并在数据变化时只更新与之相关的部分 UI。

#### 实现原理：
- **Object.defineProperty**（Vue 2）和 **Proxy**（Vue 3）是 Vue 响应式系统的基础。Vue 通过劫持对象的读取和设置操作，实现对对象的每个属性的依赖追踪。当一个响应式属性发生变化时，Vue 会触发与此属性相关的 UI 更新。

#### 依赖追踪：
- Vue 在组件渲染时，会记录哪些响应式数据被访问了（即“依赖收集”），每当这些依赖的数据变化时，Vue 知道该重新渲染哪个组件。
- 在 Vue 3 中，**`reactive`** 和 **`ref`** 使得状态变得更加灵活，使用 `reactive` 可以创建响应式对象，使用 `ref` 可以创建单个响应式值。

#### 数据变更时的更新：
- 当响应式数据变更时，Vue 会将更新操作放入一个 **队列**，并在下一次事件循环的 "微任务" 阶段合并更新，确保每个组件只渲染一次，避免不必要的重复渲染。

#### 例子：
```vue
<template>
  <div>{{ message }}</div>
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello Vue!'
    };
  }
};
</script>
```

在上面的例子中，`message` 是响应式数据，Vue 会自动追踪它的变化。如果 `message` 被修改，Vue 会自动更新 DOM。

#### 优势：
- Vue 的响应式系统自动追踪数据依赖，不需要开发者手动控制哪些数据会触发 UI 更新。
- 通过依赖追踪，Vue 可以精准地更新变化的数据，避免了不必要的 DOM 更新，提升了性能。

### **React 的数据更新机制**

React 的数据更新机制基于 **状态驱动的更新** 和 **虚拟 DOM**。不同于 Vue 自动追踪依赖，React 通过显式的状态更新来触发组件的重新渲染。

#### 状态管理：
- React 通过组件的 **`state`** 或 **`props`** 来管理数据。当 `state` 或 `props` 发生变化时，React 会重新渲染组件。
- 状态变化是显式的，开发者必须通过调用 `setState`（类组件）或 `useState`（函数组件）来更新状态。每次调用 `setState` 或 `useState`，React 会标记组件为 “脏”，然后执行重新渲染。

#### 虚拟 DOM：
- 当状态变化时，React 会先通过虚拟 DOM 重新计算整个组件的 UI 结构。虚拟 DOM 是 React 中的一个轻量级副本，它保存了当前 UI 结构的内存快照。React 会将新状态下的虚拟 DOM 与旧状态下的虚拟 DOM 进行比较（**diffing**），找出实际发生变化的部分。
- 最后，React 只更新那些与之前虚拟 DOM 不同的部分到真实 DOM，从而保证性能的优化。

#### 数据变更时的更新：
- 每次状态变化都会触发组件的重新渲染。React 会根据组件树的状态和 `props` 重新计算渲染结果。开发者可以使用 `useMemo` 或 `memo` 来避免不必要的渲染，手动优化性能。

#### 例子：
```jsx
function App() {
  const [message, setMessage] = useState('Hello React!');

  return (
    <div>
      <p>{message}</p>
      <button onClick={() => setMessage('Hello Updated React!')}>Update</button>
    </div>
  );
}
```

在 React 中，`message` 作为组件状态，使用 `useState` 来管理。每当调用 `setMessage` 改变状态时，React 会触发重新渲染，并通过虚拟 DOM 对比来决定要更新的 DOM 节点。

#### 优势：
- React 的状态更新是显式的，使得数据流动更加透明和可控。开发者通过 `setState` 或 `useState` 清晰地知道何时状态会更新。
- React 通过虚拟 DOM 和 diff 算法确保每次状态变化后，只更新需要更新的部分，提高性能。


END
<!--ID: 1726243533986-->
