---
created: 星期四, 八月 22日 2024, 10:28:44 晚上, 1724336924000
modified: 星期四, 八月 22日 2024, 10:28:44 晚上, 1724336924000
---

TAG: React
DECK: 前端
## 缓存和性能优化

主要指useCallback、useMemo、memo这些API。

最典型的应用是，用useMemo缓存组件内值、useCallback缓存组件内函数，结合React.memo包裹子组件以**防止子组件的不必要更新**。

注意：
**props进行的都是浅比较，但是如果不用React.memo包裹的话，不论props变化没有都会重新渲染。**

即使组件内的值、函数前后渲染都是“一样的”，但对象、函数重新创建会生成新的引用，也会引起重新渲染（因为React.memo进行的是浅层比较）。

---

### 为什么要缓存
JSX里的代码在组件每次重新渲染时候都会重新执行，对于一些直接在JSX里定义的变量（没有使用useState，包括函数、变量），可能带来不必要的重复计算。  
  
### 相关API
useCallback缓存函数、useMemo缓存值，都传入一个依赖数组，根据依赖数组的变化而变化，其他情况下直接得到缓存值。  
  
useRef可以用于存储可变值，这些值在组件重新渲染时不会改变。它可以用于缓存 DOM 元素或存储一些不需要触发重新渲染的数据。（没有根据依赖数组变化而变化的特性）  
  
memo缓存组件，只有在传入prop发生改变时才重新渲染。默认情况下，`React.memo` 使用浅比较来判断 `props` 是否变化。如果你需要更复杂的比较逻辑，可以传递一个自定义的比较函数作为第二个参数。 
![image.png](https://tazdingo-images.oss-cn-hongkong.aliyuncs.com/202409180032590.png)

  
### 最佳实践
不是一股脑都用的，一方面会增加代码的复杂性，另一方面这些hooks本身也有开销。  
对于useCallback、useMemo：  
- 函数/值作为 `props` 传递给子组件，且子组件使用 `React.memo` 或其他优化方法。
- 函数/值依赖于某些状态或 `props`，并且该状态或 `props` 不经常改变。
- 防止由于函数重新创建导致的性能问题，特别是**在复杂的渲染逻辑或高频率更新的情况下**。  

对于React.memo：  
- 子组件在大多数情况下不需要重新渲染，只有在 `props` 确实发生变化时才需要重新渲染时。
- 子组件渲染过程比较复杂或耗时，且频繁重新渲染会影响性能。
  
效果不好的情况：  
- 回调函数/值/组件非常简单或渲染过程耗时不多，可能不会带来显著的性能提升。
- 如果回调函数/值/子组件依赖于上下文或 `props` 经常变化，可能不会有效避免重新渲染。


END
<!--ID: 1726590927984-->

