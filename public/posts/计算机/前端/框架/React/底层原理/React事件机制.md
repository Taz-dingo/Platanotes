TAG: React
DECK: 前端
## React 事件机制

React 的事件机制与原生浏览器事件机制存在一些差异。React 为了提供更好的跨浏览器兼容性和性能优化，使用了一种称为**合成事件**（SyntheticEvent）的机制。

- **合成事件**：React 使用合成事件机制提供跨浏览器的统一 API，同时通过事件委托提升性能。
- **事件委托与批量更新**：React 通过事件委托和批量更新机制优化了性能，特别是在处理大量 DOM 操作时。
- **与原生事件的交互**：React 的合成事件与浏览器的原生事件并存，但 React 主要通过合成事件处理，确保跨平台的一致性。

### 1. **合成事件 (SyntheticEvent)**
React 通过合成事件封装了浏览器的原生事件。合成事件是一个跨浏览器包装层，提供了统一的 API，确保事件在不同的浏览器中表现一致。它模拟了浏览器原生事件，但不是直接在 DOM 上绑定事件。

- **工作原理：**
  React 会将所有事件监听器统一绑定在一个顶层元素上（如 `document` 或 `root`），然后通过事件委托的方式处理子元素的事件。这意味着不论有多少个子元素的事件处理函数，它们都会在同一个地方注册，从而减少性能开销。

- **事件处理：**
  React 会在事件触发时将原生事件对象包装为合成事件对象，并传递给事件处理程序。合成事件与原生事件不同，它在 React 处理结束后会被释放（性能优化的一部分），因此无法异步访问合成事件对象。

  ```jsx
  const handleClick = (event) => {
    console.log(event); // SyntheticEvent
  };
  ```

### 2. **事件委托与事件冒泡**
React 的事件系统并不是在每个 DOM 元素上直接绑定事件处理程序，而是通过事件委托的方式来处理。

事件委托流程：
1. **事件注册：** React 在初始化时，会将所有事件处理器（如 `onClick`、`onChange` 等）统一绑定到一个根元素上，通常是 `document` 或 React 渲染的根节点。
2. **事件冒泡：** 当子元素触发事件时，该事件会沿着 DOM 树向上冒泡。React 的事件系统会监听这些事件，然后根据事件的冒泡路径找到对应的组件和事件处理函数。
3. **事件处理：** 一旦事件冒泡到根节点，React 会根据虚拟 DOM 树，找到触发该事件的具体元素，并调用相应的事件处理函数。
事件委托的优势：
1. **性能优化：** 由于 React 只需要在根节点上注册一次事件处理程序，无论页面中有多少个可交互的元素，React 都不会在每个元素上单独绑定事件处理器。这减少了内存的消耗和性能开销，尤其是当页面上有大量的事件时。
2. **跨浏览器兼容性：** React 的事件系统屏蔽了浏览器之间的差异，通过合成事件提供了一致的 API，确保事件行为在所有浏览器中一致。
3. **动态元素的支持：** 对于动态创建或销毁的元素，React 不需要额外绑定和解绑事件处理程序，因为所有的事件处理都是通过顶层的事件委托实现的。

### 3. **事件优先级与批量更新**
在 React 中，事件优先级会影响 UI 更新的时机。React 通过批量更新机制优化渲染性能，这意味着多个事件触发时，React 会等待所有事件处理完成后再统一更新 DOM。
- **批量更新：**
  当在事件处理函数中进行状态更新时，React 并不会立即更新 DOM，而是将所有更新操作批量处理。

  ```jsx
  const handleClick = () => {
    setState1(newValue1);
    setState2(newValue2);
  };
  // 上述两个状态更新操作会合并成一次重新渲染
  ```

### 4. **原生事件与合成事件的并存**
在某些情况下，可以同时使用 React 的合成事件与原生浏览器事件。不过要注意 React 的合成事件与原生事件的优先级和行为可能不一致。
- **阻止默认行为与冒泡：**
  React 的合成事件支持 `preventDefault()` 和 `stopPropagation()`，但需要注意合成事件是异步处理的，处理顺序可能与原生事件不同。

  ```jsx
  const handleClick = (event) => {
    event.preventDefault();  // 阻止默认行为
    event.stopPropagation(); // 阻止事件冒泡
  };
  ```

  如果想处理原生事件，可以通过 `event.nativeEvent` 访问到原生事件对象：

  ```jsx
  const handleClick = (event) => {
    console.log(event.nativeEvent); // 原生事件
  };
  ```

### 5. **事件解绑**
与浏览器的事件绑定方式不同，React 会在组件卸载时自动解绑事件处理函数，而无需手动移除。原生浏览器事件处理则需要手动通过 `removeEventListener` 进行解绑，避免内存泄漏。

### 6. **事件捕获**
React 支持事件捕获和事件冒泡两种模式，可以通过在事件名前添加 `capture` 来启用捕获模式：
```jsx
<div onClickCapture={handleClick}> // 捕获阶段触发
  <button>Click me</button>
</div>
```




[^1]: [美团前端二面经典react面试题总结](https://www.cnblogs.com/xiatianweidao/p/17168684.html "发布于 2023-03-01 16:19")

END
<!--ID: 1726891610998-->

