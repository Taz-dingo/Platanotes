---
created: 星期二, 九月 24日 2024, 4:02:23 下午, 1727164943996
modified: 星期二, 九月 24日 2024, 4:02:23 下午, 1727164943996
---

TAG: React
DEKC: 前端
## key的作用

从底层原理来说，`key` 是 React 在协调（**reconciliation**）过程中的一个重要机制，用于在虚拟 DOM 中高效地比较新旧节点，并准确地更新真实的 DOM。

当 React 处理一个由同类型元素组成的列表时（如一个 `<ul>` 内有多个 `<li>`），为了避免不必要的删除、插入或重新排列，它依赖 `key` 来唯一标识每个元素。`key` 允许 React 在不同渲染周期之间识别这些元素是否在相同的位置，帮助它进行更高效的更新。

- **如果没有 `key`**，React 默认会假设列表中元素的顺序发生了改变，即使元素的内容可能没有变化。在这种情况下，React 可能会导致不必要的 DOM 操作，例如删除和重新创建相同的元素，导致性能下降。
- **有了 `key`**，React 可以明确知道某个元素的位置，即使位置发生了改变，React 仍然可以正确地复用已经存在的元素，减少 DOM 操作。

---

### **Diff 算法如何使用 `key`**
1. **节点对比**：
   当 React 进行 Diff 算法时，它会逐层遍历新旧虚拟 DOM 树。对于普通的非列表节点，React 通过**类型**（如 `div`、`span` 等）来判断节点是否相同；对于列表中的元素，React 通过 `key` 来进一步优化判断。
2. **列表元素处理**：
   当 React 处理一组子元素时，会先检查这些子元素是否有相同的 `key`：
   - 如果 `key` 相同，React 假定这个元素是相同的，进行内容更新，而不是删除旧节点、创建新节点。
   - 如果 `key` 不同或缺失，React 认为这些元素是不同的，即使它们看起来相似（内容相同但 `key` 不同，React 也会认为它们是不同的节点）。
3. **更新规则**：
   - **插入新节点**：如果新的虚拟 DOM 中的 `key` 在旧的虚拟 DOM 中找不到，React 会插入新的节点。
   - **删除旧节点**：如果旧的虚拟 DOM 中的 `key` 在新的虚拟 DOM 中找不到，React 会删除对应的节点。
   - **移动节点**：如果一个节点的 `key` 在新旧虚拟 DOM 中都存在，但位置发生了变化，React 会将节点移动到新的位置，而不是删除旧的节点重新创建。

### **`key` 带来的优化**
- **减少不必要的 DOM 操作**：`key` 让 React 能够精确追踪元素，从而只更新需要更新的节点。避免了大量的删除和重新创建操作，提升性能。
- **减少组件的状态重置**：React 能通过 `key` 区分元素是否为同一个组件实例。例如，表单输入字段在更新过程中，如果元素被认为是相同的，React 可以保留用户的输入状态，而不会因为节点重建而丢失。

### **React 处理没有 `key` 的情况**
如果没有提供 `key`，React 会使用默认的**数组索引**作为 `key`。这在某些简单情况下可能是可行的，但在列表的元素增删或重新排序时，索引作为 `key` 可能会导致一些错误的优化结果，比如：
- 元素顺序发生变化时，React 可能会错误地认为元素内容也发生了变化，导致不必要的 DOM 操作。
- 由于 React 依赖索引来跟踪状态，用户输入或组件状态可能会被错误地重置。

### 例子：`key` 带来的差异
假设有一个组件渲染了一组列表项，如果 `key` 使用不当，会导致渲染的问题：

```jsx
// 错误使用 key：使用数组索引
const items = ['Apple', 'Banana', 'Cherry'];
return (
  <ul>
    {items.map((item, index) => (
      <li key={index}>{item}</li>
    ))}
  </ul>
);

// 正确使用 key：使用唯一标识符
const items = [{ id: 1, name: 'Apple' }, { id: 2, name: 'Banana' }, { id: 3, name: 'Cherry' }];
return (
  <ul>
    {items.map((item) => (
      <li key={item.id}>{item.name}</li>
    ))}
  </ul>
);
```

在第一个例子中，如果列表的顺序发生变化，React 会误以为是列表中的元素被更新了，导致额外的重新渲染操作。而在第二个例子中，`key` 是稳定且唯一的，React 能够更准确地识别元素，只更新实际变化的部分。


END
<!--ID: 1727190963579-->
