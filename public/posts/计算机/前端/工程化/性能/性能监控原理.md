---
created: 星期二, 九月 24日 2024, 5:16:24 下午, 1727169384205
modified: 星期二, 九月 24日 2024, 5:16:24 下午, 1727169384205
---

TAG：工程化
DECK：前端

## 性能监控原理
前端性能检测依赖于浏览器提供的性能监控API、事件钩子和网络请求的分析。

前端性能检测的原理主要依赖于：
- 浏览器提供的API（**Navigation Timing API**、**Resource Timing API** 和 **Paint Timing API** ）
- 网络请求的分析工具
- 资源加载流程的优化
- 对交互事件的跟踪。

通过这些工具，开发者可以精确地了解页面各个阶段的性能表现，识别性能瓶颈并进行优化。

### 1. **浏览器的事件周期和导航阶段**
浏览器在加载页面时会经历多个步骤，这些步骤有明确的标志点，前端性能检测基于这些标志点来测量各个阶段的耗时：
- **DNS解析**: 解析域名到IP地址。
- **TCP连接**: 建立浏览器与服务器之间的TCP连接，包括TLS/SSL握手时间。
- **请求发送**: 浏览器向服务器发送HTTP请求。
- **响应接收**: 接收服务器返回的数据，直到第一个字节到达（即TTFB）。
- **DOM解析与渲染**: 将HTML解析成DOM树，CSS解析为CSSOM树，随后生成渲染树并布局和绘制页面内容。
- **资源加载**: 异步加载的外部资源如图片、CSS、JS等被请求、下载和解析。

这些阶段的时间点通过浏览器提供的 **Navigation Timing API**、**Resource Timing API** 和 **Paint Timing API** 进行监控和分析。

### 2. **Performance API**
浏览器提供了 **Performance API** 来精确地捕捉和记录页面的性能数据。常见的API包括：
- **`performance.now()`**: 返回从页面开始加载到调用该函数的时间（以毫秒计）。它的精度极高，用于测量精确到微秒级别的性能。
- **`performance.getEntriesByType('navigation')`**: 通过 `PerformanceNavigationTiming` 对象，获取从页面加载的各个阶段的时间数据，如 `connectStart`、`responseStart`、`domContentLoadedEventEnd` 等。
- **`performance.getEntriesByType('resource')`**: 获取每个资源的请求和加载时间信息，帮助开发者了解资源加载的效率。

### 3. **Web Vitals和关键性能指标**
Web Vitals 是谷歌提出的衡量用户体验的核心指标工具，依赖于浏览器的内建机制，如以下几项：
- **First Contentful Paint (FCP)**: 利用 **Paint Timing API**，监测页面首次绘制任何内容的时间，通过捕获 `first-contentful-paint` 事件来确定。
- **Largest Contentful Paint (LCP)**: 利用 **Largest Contentful Paint API**，浏览器会记录页面中最大的可见元素加载的时间。这通过观察DOM的 `largest-contentful-paint` 事件完成。
- **Cumulative Layout Shift (CLS)**: 通过 **Layout Instability API**，监测页面的视觉稳定性。每次布局发生变化时，API会捕获并计算布局偏移的分数。
- **First Input Delay (FID)**: 通过捕获用户的首次交互事件（如点击、键盘输入）到浏览器响应的时间差，通过事件监听器实现，比如 `click` 或 `keydown`。

### 4. **网络请求性能**
浏览器使用 **Resource Timing API** 来提供详细的网络请求时间数据，包括DNS查找、连接建立、请求发送、响应接收、资源下载等时间点。例如：
- `requestStart` 到 `responseEnd` 用于计算资源请求的整个生命周期。
- `domainLookupStart` 到 `domainLookupEnd` 用于计算DNS解析时间。

### 5. **渲染和绘制性能**
- **帧率 (FPS)**: 渲染和绘制性能通过 **Request Animation Frame (RAF)** 来测量。浏览器使用 `window.requestAnimationFrame` 以每秒60帧（理想帧率）的频率调用回调函数，开发者可以计算页面渲染的帧率，分析页面动画和交互是否足够流畅。
- **长任务监测**: 使用 **Long Tasks API**，浏览器可以检测主线程被阻塞的时间，帮助识别阻塞用户交互的长任务。例如，超过50ms的任务会被记录为长任务。

### 6. **异步任务和事件监听**
- 通过捕获用户与页面的交互事件（如 `click`、`input`），结合 **Performance Observer**，可以测量 `First Input Delay` 等用户交互性能。浏览器会在事件触发和任务执行之间计算延迟。

### 7. **资源加载顺序与优化**
通过分析网络层的资源加载顺序（利用 `Resource Timing API` 和 `network waterfall`），可以发现性能瓶颈，如某些资源阻塞了页面渲染或关键路径（Critical Path）。通过资源加载的优先级管理（如 `preload`、`async`、`defer` 等），开发者可以优化这些阻塞。

### 8. **缓存命中与CDN**
通过 **HTTP Headers**，浏览器会检测资源是否来自缓存（如`cache-control`、`etag`等），并提供资源的缓存命中率信息。这些信息通常通过 `performance.getEntriesByType('resource')` 来分析。


END
<!--ID: 1727542935253-->
