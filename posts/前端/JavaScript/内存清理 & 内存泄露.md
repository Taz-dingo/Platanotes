TAG: JS
## 内存清理
所谓垃圾内存，就是没有被占用而没被使用的内存。
### V8引擎的内存清理机制

V8引擎使用了一种**标记-清除算法**（Mark-and-Sweep）作为其主要的垃圾回收机制，同时结合了其他优化技术来提高性能。

#### 标记-清除算法

V8使用的核心垃圾回收算法是标记-清除：

1. **标记阶段**：垃圾回收器从根对象（如全局对象）开始，递归地遍历所有可以通过引用访问的对象。这些可以访问的对象会被标记为"活动"。
2. **清除阶段**：未被标记为"活动"的对象被视为不可访问的，垃圾回收器会将它们的内存空间释放。

这个过程可以解决内存泄漏的问题，因为它可以清除那些不再被引用的对象。

#### 分代回收（Generational Garbage Collection）

V8采用了**分代垃圾回收**策略，将内存分为两个代：

- **新生代**（Young Generation）：存储生命周期较短的小对象。新创建的对象会分配在新生代中。
- **老生代**（Old Generation）：存储生命周期较长的对象。经过多次垃圾回收后仍然存活的对象会被提升到老生代。

新生代内存较小，V8采用了**Scavenge算法**来进行高效的垃圾回收。老生代的对象回收则使用了标记-清除和压缩等技术。

#### Scavenge算法（新生代回收）

Scavenge是V8用于新生代回收的算法，它基于一种叫**Cheney算法**的复制式垃圾回收：

1. 新生代内存分为两个区域：From space 和 To space。新对象被分配在From space。
2. 当From space满了时，垃圾回收器会遍历所有存活的对象，并将它们复制到To space。
3. 复制完成后，From space中的内存会全部清空，From和To space交换角色。

由于新生代中大多数对象生命周期很短，这种复制算法在新生代中非常高效。

#### 老生代回收

老生代中的对象会使用更复杂的标记-清除和标记-压缩技术：

1. **标记-清除**：标记所有存活的对象并清除未被标记的对象。
2. **标记-压缩**：因为老生代的内存较大，经过多次回收后，内存会变得不连续，因此需要压缩内存来减少碎片化。

#### 增量和并发垃圾回收

为了减少垃圾回收过程中对应用程序执行的中断（"暂停"），V8采用了增量垃圾回收（Incremental Garbage Collection）和并发垃圾回收（Concurrent Garbage Collection）：

- **增量回收**：将标记过程分解为多个小的增量步骤，而不是一次性完成，从而减少一次性暂停时间。
- **并发回收**：在不影响主线程执行的情况下，V8在后台并发执行一些回收操作。

### 3. V8内存回收的优化

V8引擎为提升内存管理的性能做了很多优化：

- **对象分代策略**：利用新生代和老生代的分离，提高了垃圾回收的效率。
- **内存池管理**：V8会为每个对象分配一个固定大小的内存块，在释放内存时也会直接释放整个内存块，从而减少碎片化。
- **延迟回收**：V8通过延迟回收策略，确保在关键代码段中垃圾回收不会频繁触发，从而提升程序性能。

END
<!--ID: 1722864511531-->




---

## 常见的内存泄露
1. 意外的全局变量（非严格模式下，失败的LHS查询隐式创建。用人话说就是对一个没有声明的变量赋值，会隐式创建该变量标识符的全局变量）
2. 未清理的定时器
3. 闭包函数

END
<!--ID: 1722864511533-->


